{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = _interopDefault(require('react'));\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype.__proto__ = superClass && superClass.prototype;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar ResizeSensor = createCommonjsModule(function (module, exports) {\n  /**\n   * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n   * directory of this distribution and at\n   * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n   */\n  (function (root, factory) {\n    if (typeof undefined === \"function\" && undefined.amd) {\n      undefined(factory);\n    } else {\n      module.exports = factory();\n    }\n  })(typeof window !== 'undefined' ? window : commonjsGlobal, function () {\n    // Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n      return null;\n    } // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n\n\n    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n      return window.setTimeout(fn, 20);\n    };\n    /**\n     * Iterate over each of the provided element(s).\n     *\n     * @param {HTMLElement|HTMLElement[]} elements\n     * @param {Function}                  callback\n     */\n\n\n    function forEachElement(elements, callback) {\n      var elementsType = Object.prototype.toString.call(elements);\n      var isCollectionTyped = '[object Array]' === elementsType || '[object NodeList]' === elementsType || '[object HTMLCollection]' === elementsType || '[object Object]' === elementsType || 'undefined' !== typeof jQuery && elements instanceof jQuery //jquery\n      || 'undefined' !== typeof Elements && elements instanceof Elements //mootools\n      ;\n      var i = 0,\n          j = elements.length;\n\n      if (isCollectionTyped) {\n        for (; i < j; i++) {\n          callback(elements[i]);\n        }\n      } else {\n        callback(elements);\n      }\n    }\n    /**\n    * Get element size\n    * @param {HTMLElement} element\n    * @returns {Object} {width, height}\n    */\n\n\n    function getElementSize(element) {\n      if (!element.getBoundingClientRect) {\n        return {\n          width: element.offsetWidth,\n          height: element.offsetHeight\n        };\n      }\n\n      var rect = element.getBoundingClientRect();\n      return {\n        width: Math.round(rect.width),\n        height: Math.round(rect.height)\n      };\n    }\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n\n\n    var ResizeSensor = function (element, callback) {\n      /**\n       *\n       * @constructor\n       */\n      function EventQueue() {\n        var q = [];\n\n        this.add = function (ev) {\n          q.push(ev);\n        };\n\n        var i, j;\n\n        this.call = function () {\n          for (i = 0, j = q.length; i < j; i++) {\n            q[i].call();\n          }\n        };\n\n        this.remove = function (ev) {\n          var newQueue = [];\n\n          for (i = 0, j = q.length; i < j; i++) {\n            if (q[i] !== ev) newQueue.push(q[i]);\n          }\n\n          q = newQueue;\n        };\n\n        this.length = function () {\n          return q.length;\n        };\n      }\n      /**\n       *\n       * @param {HTMLElement} element\n       * @param {Function}    resized\n       */\n\n\n      function attachResizeEvent(element, resized) {\n        if (!element) return;\n\n        if (element.resizedAttached) {\n          element.resizedAttached.add(resized);\n          return;\n        }\n\n        element.resizedAttached = new EventQueue();\n        element.resizedAttached.add(resized);\n        element.resizeSensor = document.createElement('div');\n        element.resizeSensor.dir = 'ltr';\n        element.resizeSensor.className = 'resize-sensor';\n        var style = 'position: absolute; left: -10px; top: -10px; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n        var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n        element.resizeSensor.style.cssText = style;\n        element.resizeSensor.innerHTML = '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' + '<div style=\"' + styleChild + '\"></div>' + '</div>' + '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' + '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' + '</div>';\n        element.appendChild(element.resizeSensor);\n        var position = window.getComputedStyle(element).getPropertyValue('position');\n\n        if ('absolute' !== position && 'relative' !== position && 'fixed' !== position) {\n          element.style.position = 'relative';\n        }\n\n        var expand = element.resizeSensor.childNodes[0];\n        var expandChild = expand.childNodes[0];\n        var shrink = element.resizeSensor.childNodes[1];\n        var dirty, rafId, newWidth, newHeight;\n        var size = getElementSize(element);\n        var lastWidth = size.width;\n        var lastHeight = size.height;\n\n        var reset = function () {\n          //set display to block, necessary otherwise hidden elements won't ever work\n          var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;\n\n          if (invisible) {\n            var saveDisplay = element.style.display;\n            element.style.display = 'block';\n          }\n\n          expandChild.style.width = '100000px';\n          expandChild.style.height = '100000px';\n          expand.scrollLeft = 100000;\n          expand.scrollTop = 100000;\n          shrink.scrollLeft = 100000;\n          shrink.scrollTop = 100000;\n\n          if (invisible) {\n            element.style.display = saveDisplay;\n          }\n        };\n\n        element.resizeSensor.resetSensor = reset;\n\n        var onResized = function () {\n          rafId = 0;\n          if (!dirty) return;\n          lastWidth = newWidth;\n          lastHeight = newHeight;\n\n          if (element.resizedAttached) {\n            element.resizedAttached.call();\n          }\n        };\n\n        var onScroll = function () {\n          var size = getElementSize(element);\n          var newWidth = size.width;\n          var newHeight = size.height;\n          dirty = newWidth != lastWidth || newHeight != lastHeight;\n\n          if (dirty && !rafId) {\n            rafId = requestAnimationFrame(onResized);\n          }\n\n          reset();\n        };\n\n        var addEvent = function (el, name, cb) {\n          if (el.attachEvent) {\n            el.attachEvent('on' + name, cb);\n          } else {\n            el.addEventListener(name, cb);\n          }\n        };\n\n        addEvent(expand, 'scroll', onScroll);\n        addEvent(shrink, 'scroll', onScroll); // Fix for custom Elements\n\n        requestAnimationFrame(reset);\n      }\n\n      forEachElement(element, function (elem) {\n        attachResizeEvent(elem, callback);\n      });\n\n      this.detach = function (ev) {\n        ResizeSensor.detach(element, ev);\n      };\n\n      this.reset = function () {\n        element.resizeSensor.resetSensor();\n      };\n    };\n\n    ResizeSensor.reset = function (element, ev) {\n      forEachElement(element, function (elem) {\n        elem.resizeSensor.resetSensor();\n      });\n    };\n\n    ResizeSensor.detach = function (element, ev) {\n      forEachElement(element, function (elem) {\n        if (!elem) return;\n\n        if (elem.resizedAttached && typeof ev === \"function\") {\n          elem.resizedAttached.remove(ev);\n          if (elem.resizedAttached.length()) return;\n        }\n\n        if (elem.resizeSensor) {\n          if (elem.contains(elem.resizeSensor)) {\n            elem.removeChild(elem.resizeSensor);\n          }\n\n          delete elem.resizeSensor;\n          delete elem.resizedAttached;\n        }\n      });\n    };\n\n    return ResizeSensor;\n  });\n});\n\nvar SizeObservable =\n/*#__PURE__*/\nfunction () {\n  function SizeObservable(element) {\n    this.element = element;\n    this.observers = [];\n    this.handleResize = this.handleResize.bind(this);\n    this.createSizeObservable();\n  }\n\n  var _proto = SizeObservable.prototype;\n\n  _proto.register = function register(observer) {\n    this.observers.push(observer);\n  };\n\n  _proto.unregister = function unregister(observerToUnregister) {\n    this.observers = this.observers.filter(function (observer) {\n      return observer !== observerToUnregister;\n    });\n  };\n\n  _proto.handleResize = function handleResize() {\n    var size = getSize(this.element);\n    this.observers.forEach(function (observer) {\n      return observer(size);\n    });\n  };\n\n  _proto.createSizeObservable = function createSizeObservable() {\n    return new ResizeSensor(this.element, this.handleResize);\n  };\n\n  return SizeObservable;\n}();\n\nfunction getSize(element) {\n  return {\n    height: element.clientHeight,\n    width: element.clientWidth\n  };\n}\n\nvar ResizeObservingContainer =\n/*#__PURE__*/\nfunction (_React$Component) {\n  function ResizeObservingContainer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      height: null,\n      width: null\n    };\n    _this.container = React.createRef();\n    _this.createSizeObservable = _this.createSizeObservable.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.notifyHeightChange = _this.notifyHeightChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.notifyWidthChange = _this.notifyWidthChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.updateSize = _this.updateSize.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  var _proto = ResizeObservingContainer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.createSizeObservable(this.container.current);\n  };\n\n  _proto.notifyHeightChange = function notifyHeightChange(_ref) {\n    var height = _ref.height;\n\n    if (height !== this.state.height) {\n      executeIfDefined(this.props.onHeightChange, height);\n    }\n  };\n\n  _proto.notifyWidthChange = function notifyWidthChange(_ref2) {\n    var width = _ref2.width;\n\n    if (width !== this.state.width) {\n      executeIfDefined(this.props.onWidthChange, width);\n    }\n  };\n\n  _proto.updateSize = function updateSize(size) {\n    this.setState(size);\n  };\n\n  _proto.createSizeObservable = function createSizeObservable(element) {\n    var sizeObservable = new SizeObservable(element);\n    sizeObservable.register(this.notifyHeightChange);\n    sizeObservable.register(this.notifyWidthChange);\n    sizeObservable.register(this.updateSize);\n  };\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    var passedProps = Object.assign({}, this.props);\n    delete passedProps.onHeightChange;\n    delete passedProps.onWidthChange;\n    delete passedProps.children;\n    return React.createElement(\"div\", _extends({}, passedProps, {\n      ref: this.container\n    }), children);\n  };\n\n  _inheritsLoose(ResizeObservingContainer, _React$Component);\n\n  return ResizeObservingContainer;\n}(React.Component);\n\nfunction executeIfDefined(func) {\n  if (typeof func === 'function') {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n\n    func.apply(void 0, params);\n  }\n}\n\nResizeObservingContainer.propTypes = {\n  children: PropTypes.node,\n  onHeightChange: PropTypes.func,\n  onWidthChange: PropTypes.func\n};\n\nfunction getSafeNumberOfColumns(numberOfColumns) {\n  return numberOfColumns > 0 ? numberOfColumns : 1;\n}\n\nfunction round(value, decimals) {\n  var decimalsShift = Math.pow(10, decimals);\n  return Math.round(value * decimalsShift) / decimalsShift;\n}\n\nvar WIDTH_PRECISION = 2;\n\nfunction getColumnWidth(numberOfColumns) {\n  var safeNumberOfColumns = getSafeNumberOfColumns(numberOfColumns);\n  var width = 100 / safeNumberOfColumns;\n  return round(width, WIDTH_PRECISION);\n}\n\nfunction getOuterGutterPortion(gutterWidth, numberOfColumns) {\n  var safeNumberOfColumns = getSafeNumberOfColumns(numberOfColumns);\n  return gutterWidth / safeNumberOfColumns;\n}\n\nvar DEFAULT_ITEM_STYLES = {\n  horizontalGutterShift: 0,\n  left: 0,\n  top: 0\n};\n\nfunction getItemStyles(item, dridStyles) {\n  var mergedStyles = Object.assign({}, DEFAULT_ITEM_STYLES, item, dridStyles);\n  mergedStyles.outerGutterPortion = getOuterGutterPortion(dridStyles.gutterWidth, dridStyles.numberOfColumns);\n  return dridStyles.gridWidth ? getItemStylesForKnownWidth(mergedStyles) : getItemStylesForUnknownWidth(mergedStyles);\n}\n\nfunction getItemStylesForKnownWidth(_ref) {\n  var columnWidth = _ref.columnWidth,\n      horizontalGutterShift = _ref.horizontalGutterShift,\n      gridWidth = _ref.gridWidth,\n      outerGutterPortion = _ref.outerGutterPortion,\n      gutterWidth = _ref.gutterWidth,\n      left = _ref.left,\n      top = _ref.top,\n      transition = _ref.transition;\n  return {\n    left: left * gridWidth / 100 + horizontalGutterShift + \"px\",\n    position: 'absolute',\n    top: top + \"px\",\n    transition: transition,\n    width: gridWidth * columnWidth / 100 - gutterWidth + outerGutterPortion + \"px\"\n  };\n}\n\nfunction getItemStylesForUnknownWidth(_ref2) {\n  var columnWidth = _ref2.columnWidth,\n      horizontalGutterShift = _ref2.horizontalGutterShift,\n      outerGutterPortion = _ref2.outerGutterPortion,\n      gutterWidth = _ref2.gutterWidth,\n      left = _ref2.left,\n      top = _ref2.top,\n      transition = _ref2.transition;\n  return {\n    left: \"calc(\" + left + \"% + \" + horizontalGutterShift + \"px)\",\n    position: 'absolute',\n    top: top + \"px\",\n    transition: transition,\n    width: \"calc(\" + columnWidth + \"% - \" + gutterWidth + \"px + \" + outerGutterPortion + \"px)\"\n  };\n}\n\nfunction FluidGridItem(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      columnWidth = _ref.columnWidth,\n      gridWidth = _ref.gridWidth,\n      gutterWidth = _ref.gutterWidth,\n      item = _ref.item,\n      index = _ref.index,\n      numberOfColumns = _ref.numberOfColumns,\n      onHeightChange = _ref.onHeightChange,\n      registerItem = _ref.registerItem,\n      transition = _ref.transition;\n\n  if (!children) {\n    return null;\n  }\n\n  var style = getItemStyles(item, {\n    columnWidth: columnWidth,\n    gridWidth: gridWidth,\n    gutterWidth: gutterWidth,\n    numberOfColumns: numberOfColumns,\n    transition: transition\n  });\n  return React.createElement(\"div\", {\n    className: className,\n    ref: registerItem,\n    style: style\n  }, React.createElement(ResizeObservingContainer, {\n    onHeightChange: onHeightChange\n  }, children));\n}\n\nFluidGridItem.propTypes = {\n  children: PropTypes.node,\n  className: PropTypes.string,\n  columnWidth: PropTypes.number,\n  gridWidth: PropTypes.number,\n  gutterWidth: PropTypes.number,\n  item: PropTypes.object,\n  index: PropTypes.number.isRequired,\n  numberOfColumns: PropTypes.number,\n  onHeightChange: PropTypes.func.isRequired,\n  registerItem: PropTypes.func.isRequired,\n  transition: PropTypes.string\n};\nFluidGridItem.defaultProps = {\n  className: '',\n  transition: 'top 200ms ease-in-out, left 200ms ease-in-out, width 200ms ease-in-out'\n};\n\nfunction getShortestColumn(columns) {\n  var getShortest = function getShortest(shortestColumn, column, index) {\n    return shortestColumn.height <= column.height ? shortestColumn : column;\n  };\n\n  return columns.reduce(getShortest, columns[0]);\n}\n\nfunction getLongestColumn(columns) {\n  var getLongest = function getLongest(longestColumn, column, index) {\n    return longestColumn.height > column.height ? longestColumn : column;\n  };\n\n  return columns.reduce(getLongest, columns[0]);\n}\n\nvar INITIAL_HEIGHT = 0;\n\nfunction getColumns(columnWidth, gutterWidth, numberOfColumns) {\n  var columns = [];\n\n  for (var i = 0; i < numberOfColumns; i++) {\n    columns.push({\n      height: INITIAL_HEIGHT,\n      horizontalGutterShift: gutterWidth * i / numberOfColumns,\n      left: columnWidth * i\n    });\n  }\n\n  return columns;\n}\n\nfunction getColumnHeightShift(itemHeight, gutterHeight) {\n  return itemHeight ? itemHeight + gutterHeight : 0;\n}\n\nvar defaultStyleStrategies = [{\n  mediaQuery: '(max-width: 719.9px)',\n  style: {\n    numberOfColumns: 1,\n    gutterHeight: 8,\n    gutterWidth: 8\n  }\n}, {\n  mediaQuery: '(min-width: 720px) and (max-width: 1023.9px)',\n  style: {\n    numberOfColumns: 2,\n    gutterHeight: 16,\n    gutterWidth: 16\n  }\n}, {\n  mediaQuery: '(min-width: 1024px) and (max-width: 1919.9px)',\n  style: {\n    numberOfColumns: 3,\n    gutterHeight: 24,\n    gutterWidth: 24\n  }\n}, {\n  mediaQuery: '(min-width: 1920px)',\n  style: {\n    numberOfColumns: 4,\n    gutterHeight: 24,\n    gutterWidth: 24\n  }\n}];\nvar DEFAULT_STYLE = {\n  numberOfColumns: 1,\n  gutterHeight: 0,\n  gutterWidth: 0\n};\nvar detectNode = createCommonjsModule(function (module) {\n  module.exports = false; // Only Node.JS has a process variable that is of [[Class]] process\n\n  try {\n    module.exports = Object.prototype.toString.call(commonjsGlobal.process) === '[object process]';\n  } catch (e) {}\n});\n\nfunction getStyle(styleStrategies) {\n  if (detectNode) {\n    return DEFAULT_STYLE;\n  }\n\n  var matchingStrategy = styleStrategies.find(isMatch);\n  return matchingStrategy ? matchingStrategy.style : DEFAULT_STYLE;\n}\n\nfunction isMatch(_ref) {\n  var mediaQuery = _ref.mediaQuery;\n  return window.matchMedia(mediaQuery).matches;\n}\n\nvar FluidGrid =\n/*#__PURE__*/\nfunction (_React$Component) {\n  function FluidGrid(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      items: {},\n      height: '0px',\n      overflow: 'hidden',\n      position: 'relative'\n    };\n    _this.items = {};\n    _this.updateLayout = _this.updateLayout.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.renderChild = _this.renderChild.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.pushToShortestColumn = _this.pushToShortestColumn.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.updateGridStyles = _this.updateGridStyles.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  var _proto = FluidGrid.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateGridStyles();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (this.refreshRequired(prevProps, prevState)) {\n      this.updateLayout();\n    }\n  };\n\n  _proto.refreshRequired = function refreshRequired(prevProps, prevState) {\n    return prevProps.children !== this.props.children || prevState.numberOfColumns !== this.state.numberOfColumns || prevState.gutterHeight !== this.state.gutterHeight || prevState.gutterWidth !== this.state.gutterWidth;\n  };\n\n  _proto.updateLayout = function updateLayout() {\n    this.initColumns();\n    this.arrangeItems();\n    this.setGridHeight();\n    this.applyChanges();\n  };\n\n  _proto.initColumns = function initColumns() {\n    var _this$state = this.state,\n        columnWidth = _this$state.columnWidth,\n        gutterWidth = _this$state.gutterWidth,\n        numberOfColumns = _this$state.numberOfColumns;\n    this.columns = getColumns(columnWidth, gutterWidth, numberOfColumns);\n  };\n\n  _proto.arrangeItems = function arrangeItems() {\n    Object.values(this.items).forEach(this.pushToShortestColumn);\n  };\n\n  _proto.pushToShortestColumn = function pushToShortestColumn(item) {\n    var column = getShortestColumn(this.columns);\n    this.setItemStyle(item, column);\n    this.pushToColumn(item, column);\n  };\n\n  _proto.pushToColumn = function pushToColumn(item, column) {\n    var gutterHeight = this.state.gutterHeight;\n    var itemHeight = item.element.clientHeight;\n    var heightShift = getColumnHeightShift(itemHeight, gutterHeight);\n    column.height = column.height + heightShift;\n  };\n\n  _proto.setItemStyle = function setItemStyle(item, column) {\n    item.top = column.height;\n    item.left = column.left;\n    item.horizontalGutterShift = column.horizontalGutterShift;\n  };\n\n  _proto.setGridHeight = function setGridHeight() {\n    var gutterHeight = this.state.gutterHeight;\n\n    var _getLongestColumn = getLongestColumn(this.columns),\n        height = _getLongestColumn.height;\n\n    this.gridHeight = height - gutterHeight;\n  };\n\n  _proto.applyChanges = function applyChanges() {\n    this.setState({\n      height: this.gridHeight + \"px\",\n      items: this.items\n    });\n  };\n\n  _proto.updateGridStyles = function updateGridStyles(gridWidth) {\n    var _getStyle = getStyle(this.props.styleStrategies),\n        gutterHeight = _getStyle.gutterHeight,\n        gutterWidth = _getStyle.gutterWidth,\n        numberOfColumns = _getStyle.numberOfColumns;\n\n    var columnWidth = getColumnWidth(numberOfColumns);\n    this.setState({\n      columnWidth: columnWidth,\n      gridWidth: gridWidth,\n      gutterHeight: gutterHeight,\n      gutterWidth: gutterWidth,\n      numberOfColumns: numberOfColumns\n    });\n  };\n\n  _proto.renderChildren = function renderChildren() {\n    this.clearItems();\n    return this.props.children.map(this.renderChild);\n  };\n\n  _proto.clearItems = function clearItems() {\n    this.items = {};\n  };\n\n  _proto.renderChild = function renderChild(child, index) {\n    var _this2 = this;\n\n    var _this$state2 = this.state,\n        columnWidth = _this$state2.columnWidth,\n        gridWidth = _this$state2.gridWidth,\n        gutterWidth = _this$state2.gutterWidth,\n        items = _this$state2.items,\n        numberOfColumns = _this$state2.numberOfColumns;\n    var _this$props = this.props,\n        itemClassName = _this$props.itemClassName,\n        transition = _this$props.transition;\n\n    var registerItem = function registerItem(element) {\n      _this2.items[index] = {\n        element: element\n      };\n    };\n\n    return React.createElement(FluidGridItem, {\n      className: itemClassName,\n      columnWidth: columnWidth,\n      gridWidth: gridWidth,\n      gutterWidth: gutterWidth,\n      item: items[index],\n      index: index,\n      key: index,\n      numberOfColumns: numberOfColumns,\n      onHeightChange: this.updateLayout,\n      registerItem: registerItem,\n      transition: transition\n    }, child);\n  };\n\n  _proto.render = function render() {\n    var className = this.props.className;\n    var _this$state3 = this.state,\n        height = _this$state3.height,\n        overflow = _this$state3.overflow,\n        position = _this$state3.position;\n    var style = {\n      height: height,\n      overflow: overflow,\n      position: position\n    };\n    return React.createElement(\"div\", {\n      className: className,\n      style: style\n    }, React.createElement(ResizeObservingContainer, {\n      onWidthChange: this.updateGridStyles\n    }, this.renderChildren()));\n  };\n\n  _inheritsLoose(FluidGrid, _React$Component);\n\n  return FluidGrid;\n}(React.Component);\n\nvar styleStrategyShape = {\n  mediaQuery: PropTypes.string.isRequired,\n  style: PropTypes.shape({\n    numberOfColumns: PropTypes.number.isRequired,\n    gutterHeight: PropTypes.number.isRequired,\n    gutterWidth: PropTypes.number.isRequired\n  })\n};\nFluidGrid.propTypes = {\n  className: PropTypes.string,\n  children: PropTypes.node,\n  itemClassName: PropTypes.string,\n  styleStrategies: PropTypes.arrayOf(PropTypes.shape(styleStrategyShape)),\n  transition: PropTypes.string\n};\nFluidGrid.defaultProps = {\n  className: '',\n  itemClassName: '',\n  styleStrategies: defaultStyleStrategies\n};\nexports.default = FluidGrid;","map":null,"metadata":{},"sourceType":"script"}